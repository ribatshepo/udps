apiVersion: v1
kind: Secret
metadata:
  name: udps-secrets
  namespace: seri-sa-platform
  labels:
    app.kubernetes.io/name: udps
    app.kubernetes.io/component: secrets
    app.kubernetes.io/part-of: seri-sa-platform
  annotations:
    description: >
      Secret template for UDPS. All values must be base64-encoded before applying.
      Generate with: echo -n 'your-value' | base64
      In production, use a secrets manager (Vault, AWS Secrets Manager, etc.)
      and an operator like External Secrets Operator to populate these values.
type: Opaque
stringData:
  # PostgreSQL credentials
  # Replace with actual production credentials before applying
  POSTGRES_USER: "REPLACE_WITH_ACTUAL_VALUE"
  POSTGRES_PASSWORD: "REPLACE_WITH_ACTUAL_VALUE"

  # MinIO credentials
  MINIO_ROOT_USER: "REPLACE_WITH_ACTUAL_VALUE"
  MINIO_ROOT_PASSWORD: "REPLACE_WITH_ACTUAL_VALUE"

  # Redis password (if auth is enabled)
  REDIS_PASSWORD: "REPLACE_WITH_ACTUAL_VALUE"

  # Kafka SASL credentials (if auth is enabled)
  KAFKA_SASL_USERNAME: "REPLACE_WITH_ACTUAL_VALUE"
  KAFKA_SASL_PASSWORD: "REPLACE_WITH_ACTUAL_VALUE"

  # TLS certificates â€” in production, use cert-manager or mount from a Secret created
  # by your certificate provisioning pipeline
  TLS_CERT_PATH: "/etc/udps/tls/tls.crt"
  TLS_KEY_PATH: "/etc/udps/tls/tls.key"
  TLS_CA_PATH: "/etc/udps/tls/ca.crt"
---
apiVersion: v1
kind: Secret
metadata:
  name: udps-tls
  namespace: seri-sa-platform
  labels:
    app.kubernetes.io/name: udps
    app.kubernetes.io/component: tls
    app.kubernetes.io/part-of: seri-sa-platform
  annotations:
    description: >
      TLS certificate secret. In production, this should be managed by cert-manager.
      Create with: kubectl create secret tls udps-tls --cert=tls.crt --key=tls.key -n seri-sa-platform
type: kubernetes.io/tls
data:
  tls.crt: ""
  tls.key: ""
