// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package uccp.coordination.coordination


object LockServiceGrpc {
  val METHOD_ACQUIRE_LOCK: _root_.io.grpc.MethodDescriptor[uccp.coordination.coordination.AcquireLockRequest, uccp.coordination.coordination.AcquireLockResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("uccp.coordination.LockService", "AcquireLock"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[uccp.coordination.coordination.AcquireLockRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[uccp.coordination.coordination.AcquireLockResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(uccp.coordination.coordination.CoordinationProto.javaDescriptor.getServices().get(1).getMethods().get(0)))
      .build()
  
  val METHOD_RELEASE_LOCK: _root_.io.grpc.MethodDescriptor[uccp.coordination.coordination.ReleaseLockRequest, uccp.common.common.Response] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("uccp.coordination.LockService", "ReleaseLock"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[uccp.coordination.coordination.ReleaseLockRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[uccp.common.common.Response])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(uccp.coordination.coordination.CoordinationProto.javaDescriptor.getServices().get(1).getMethods().get(1)))
      .build()
  
  val METHOD_RENEW_LOCK: _root_.io.grpc.MethodDescriptor[uccp.coordination.coordination.RenewLockRequest, uccp.common.common.Response] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("uccp.coordination.LockService", "RenewLock"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[uccp.coordination.coordination.RenewLockRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[uccp.common.common.Response])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(uccp.coordination.coordination.CoordinationProto.javaDescriptor.getServices().get(1).getMethods().get(2)))
      .build()
  
  val METHOD_TRY_LOCK: _root_.io.grpc.MethodDescriptor[uccp.coordination.coordination.TryLockRequest, uccp.coordination.coordination.TryLockResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("uccp.coordination.LockService", "TryLock"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[uccp.coordination.coordination.TryLockRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[uccp.coordination.coordination.TryLockResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(uccp.coordination.coordination.CoordinationProto.javaDescriptor.getServices().get(1).getMethods().get(3)))
      .build()
  
  val METHOD_ACQUIRE_READ_LOCK: _root_.io.grpc.MethodDescriptor[uccp.coordination.coordination.AcquireReadLockRequest, uccp.coordination.coordination.AcquireLockResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("uccp.coordination.LockService", "AcquireReadLock"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[uccp.coordination.coordination.AcquireReadLockRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[uccp.coordination.coordination.AcquireLockResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(uccp.coordination.coordination.CoordinationProto.javaDescriptor.getServices().get(1).getMethods().get(4)))
      .build()
  
  val METHOD_ACQUIRE_SEMAPHORE: _root_.io.grpc.MethodDescriptor[uccp.coordination.coordination.AcquireSemaphoreRequest, uccp.coordination.coordination.AcquireSemaphoreResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("uccp.coordination.LockService", "AcquireSemaphore"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[uccp.coordination.coordination.AcquireSemaphoreRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[uccp.coordination.coordination.AcquireSemaphoreResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(uccp.coordination.coordination.CoordinationProto.javaDescriptor.getServices().get(1).getMethods().get(5)))
      .build()
  
  val METHOD_RELEASE_SEMAPHORE: _root_.io.grpc.MethodDescriptor[uccp.coordination.coordination.ReleaseSemaphoreRequest, uccp.common.common.Response] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("uccp.coordination.LockService", "ReleaseSemaphore"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[uccp.coordination.coordination.ReleaseSemaphoreRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[uccp.common.common.Response])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(uccp.coordination.coordination.CoordinationProto.javaDescriptor.getServices().get(1).getMethods().get(6)))
      .build()
  
  val METHOD_WAIT_BARRIER: _root_.io.grpc.MethodDescriptor[uccp.coordination.coordination.WaitBarrierRequest, uccp.coordination.coordination.WaitBarrierResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("uccp.coordination.LockService", "WaitBarrier"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[uccp.coordination.coordination.WaitBarrierRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[uccp.coordination.coordination.WaitBarrierResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(uccp.coordination.coordination.CoordinationProto.javaDescriptor.getServices().get(1).getMethods().get(7)))
      .build()
  
  val METHOD_LIST_LOCKS: _root_.io.grpc.MethodDescriptor[uccp.coordination.coordination.ListLocksRequest, uccp.coordination.coordination.ListLocksResponse] =
    _root_.io.grpc.MethodDescriptor.newBuilder()
      .setType(_root_.io.grpc.MethodDescriptor.MethodType.UNARY)
      .setFullMethodName(_root_.io.grpc.MethodDescriptor.generateFullMethodName("uccp.coordination.LockService", "ListLocks"))
      .setSampledToLocalTracing(true)
      .setRequestMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[uccp.coordination.coordination.ListLocksRequest])
      .setResponseMarshaller(_root_.scalapb.grpc.Marshaller.forMessage[uccp.coordination.coordination.ListLocksResponse])
      .setSchemaDescriptor(_root_.scalapb.grpc.ConcreteProtoMethodDescriptorSupplier.fromMethodDescriptor(uccp.coordination.coordination.CoordinationProto.javaDescriptor.getServices().get(1).getMethods().get(8)))
      .build()
  
  val SERVICE: _root_.io.grpc.ServiceDescriptor =
    _root_.io.grpc.ServiceDescriptor.newBuilder("uccp.coordination.LockService")
      .setSchemaDescriptor(new _root_.scalapb.grpc.ConcreteProtoFileDescriptorSupplier(uccp.coordination.coordination.CoordinationProto.javaDescriptor))
      .addMethod(METHOD_ACQUIRE_LOCK)
      .addMethod(METHOD_RELEASE_LOCK)
      .addMethod(METHOD_RENEW_LOCK)
      .addMethod(METHOD_TRY_LOCK)
      .addMethod(METHOD_ACQUIRE_READ_LOCK)
      .addMethod(METHOD_ACQUIRE_SEMAPHORE)
      .addMethod(METHOD_RELEASE_SEMAPHORE)
      .addMethod(METHOD_WAIT_BARRIER)
      .addMethod(METHOD_LIST_LOCKS)
      .build()
  
  /** --- Distributed Locking ---
    */
  trait LockService extends _root_.scalapb.grpc.AbstractService {
    override def serviceCompanion: _root_.scalapb.grpc.ServiceCompanion[LockService] = LockService
    def acquireLock(request: uccp.coordination.coordination.AcquireLockRequest): scala.concurrent.Future[uccp.coordination.coordination.AcquireLockResponse]
    def releaseLock(request: uccp.coordination.coordination.ReleaseLockRequest): scala.concurrent.Future[uccp.common.common.Response]
    def renewLock(request: uccp.coordination.coordination.RenewLockRequest): scala.concurrent.Future[uccp.common.common.Response]
    def tryLock(request: uccp.coordination.coordination.TryLockRequest): scala.concurrent.Future[uccp.coordination.coordination.TryLockResponse]
    def acquireReadLock(request: uccp.coordination.coordination.AcquireReadLockRequest): scala.concurrent.Future[uccp.coordination.coordination.AcquireLockResponse]
    def acquireSemaphore(request: uccp.coordination.coordination.AcquireSemaphoreRequest): scala.concurrent.Future[uccp.coordination.coordination.AcquireSemaphoreResponse]
    def releaseSemaphore(request: uccp.coordination.coordination.ReleaseSemaphoreRequest): scala.concurrent.Future[uccp.common.common.Response]
    def waitBarrier(request: uccp.coordination.coordination.WaitBarrierRequest): scala.concurrent.Future[uccp.coordination.coordination.WaitBarrierResponse]
    def listLocks(request: uccp.coordination.coordination.ListLocksRequest): scala.concurrent.Future[uccp.coordination.coordination.ListLocksResponse]
  }
  
  object LockService extends _root_.scalapb.grpc.ServiceCompanion[LockService] {
    implicit def serviceCompanion: _root_.scalapb.grpc.ServiceCompanion[LockService] = this
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.ServiceDescriptor = uccp.coordination.coordination.CoordinationProto.javaDescriptor.getServices().get(1)
    def scalaDescriptor: _root_.scalapb.descriptors.ServiceDescriptor = uccp.coordination.coordination.CoordinationProto.scalaDescriptor.services(1)
    def bindService(serviceImpl: LockService, executionContext: scala.concurrent.ExecutionContext): _root_.io.grpc.ServerServiceDefinition =
      _root_.io.grpc.ServerServiceDefinition.builder(SERVICE)
      .addMethod(
        METHOD_ACQUIRE_LOCK,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: uccp.coordination.coordination.AcquireLockRequest, observer: _root_.io.grpc.stub.StreamObserver[uccp.coordination.coordination.AcquireLockResponse]) => {
          serviceImpl.acquireLock(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_RELEASE_LOCK,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: uccp.coordination.coordination.ReleaseLockRequest, observer: _root_.io.grpc.stub.StreamObserver[uccp.common.common.Response]) => {
          serviceImpl.releaseLock(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_RENEW_LOCK,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: uccp.coordination.coordination.RenewLockRequest, observer: _root_.io.grpc.stub.StreamObserver[uccp.common.common.Response]) => {
          serviceImpl.renewLock(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_TRY_LOCK,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: uccp.coordination.coordination.TryLockRequest, observer: _root_.io.grpc.stub.StreamObserver[uccp.coordination.coordination.TryLockResponse]) => {
          serviceImpl.tryLock(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_ACQUIRE_READ_LOCK,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: uccp.coordination.coordination.AcquireReadLockRequest, observer: _root_.io.grpc.stub.StreamObserver[uccp.coordination.coordination.AcquireLockResponse]) => {
          serviceImpl.acquireReadLock(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_ACQUIRE_SEMAPHORE,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: uccp.coordination.coordination.AcquireSemaphoreRequest, observer: _root_.io.grpc.stub.StreamObserver[uccp.coordination.coordination.AcquireSemaphoreResponse]) => {
          serviceImpl.acquireSemaphore(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_RELEASE_SEMAPHORE,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: uccp.coordination.coordination.ReleaseSemaphoreRequest, observer: _root_.io.grpc.stub.StreamObserver[uccp.common.common.Response]) => {
          serviceImpl.releaseSemaphore(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_WAIT_BARRIER,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: uccp.coordination.coordination.WaitBarrierRequest, observer: _root_.io.grpc.stub.StreamObserver[uccp.coordination.coordination.WaitBarrierResponse]) => {
          serviceImpl.waitBarrier(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .addMethod(
        METHOD_LIST_LOCKS,
        _root_.io.grpc.stub.ServerCalls.asyncUnaryCall((request: uccp.coordination.coordination.ListLocksRequest, observer: _root_.io.grpc.stub.StreamObserver[uccp.coordination.coordination.ListLocksResponse]) => {
          serviceImpl.listLocks(request).onComplete(scalapb.grpc.Grpc.completeObserver(observer))(
            executionContext)
        }))
      .build()
  }
  
  /** --- Distributed Locking ---
    */
  trait LockServiceBlockingClient {
    def serviceCompanion: _root_.scalapb.grpc.ServiceCompanion[LockService] = LockService
    def acquireLock(request: uccp.coordination.coordination.AcquireLockRequest): uccp.coordination.coordination.AcquireLockResponse
    def releaseLock(request: uccp.coordination.coordination.ReleaseLockRequest): uccp.common.common.Response
    def renewLock(request: uccp.coordination.coordination.RenewLockRequest): uccp.common.common.Response
    def tryLock(request: uccp.coordination.coordination.TryLockRequest): uccp.coordination.coordination.TryLockResponse
    def acquireReadLock(request: uccp.coordination.coordination.AcquireReadLockRequest): uccp.coordination.coordination.AcquireLockResponse
    def acquireSemaphore(request: uccp.coordination.coordination.AcquireSemaphoreRequest): uccp.coordination.coordination.AcquireSemaphoreResponse
    def releaseSemaphore(request: uccp.coordination.coordination.ReleaseSemaphoreRequest): uccp.common.common.Response
    def waitBarrier(request: uccp.coordination.coordination.WaitBarrierRequest): uccp.coordination.coordination.WaitBarrierResponse
    def listLocks(request: uccp.coordination.coordination.ListLocksRequest): uccp.coordination.coordination.ListLocksResponse
  }
  
  class LockServiceBlockingStub(channel: _root_.io.grpc.Channel, options: _root_.io.grpc.CallOptions = _root_.io.grpc.CallOptions.DEFAULT) extends _root_.io.grpc.stub.AbstractStub[LockServiceBlockingStub](channel, options) with LockServiceBlockingClient {
    override def acquireLock(request: uccp.coordination.coordination.AcquireLockRequest): uccp.coordination.coordination.AcquireLockResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_ACQUIRE_LOCK, options, request)
    }
    
    override def releaseLock(request: uccp.coordination.coordination.ReleaseLockRequest): uccp.common.common.Response = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_RELEASE_LOCK, options, request)
    }
    
    override def renewLock(request: uccp.coordination.coordination.RenewLockRequest): uccp.common.common.Response = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_RENEW_LOCK, options, request)
    }
    
    override def tryLock(request: uccp.coordination.coordination.TryLockRequest): uccp.coordination.coordination.TryLockResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_TRY_LOCK, options, request)
    }
    
    override def acquireReadLock(request: uccp.coordination.coordination.AcquireReadLockRequest): uccp.coordination.coordination.AcquireLockResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_ACQUIRE_READ_LOCK, options, request)
    }
    
    override def acquireSemaphore(request: uccp.coordination.coordination.AcquireSemaphoreRequest): uccp.coordination.coordination.AcquireSemaphoreResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_ACQUIRE_SEMAPHORE, options, request)
    }
    
    override def releaseSemaphore(request: uccp.coordination.coordination.ReleaseSemaphoreRequest): uccp.common.common.Response = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_RELEASE_SEMAPHORE, options, request)
    }
    
    override def waitBarrier(request: uccp.coordination.coordination.WaitBarrierRequest): uccp.coordination.coordination.WaitBarrierResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_WAIT_BARRIER, options, request)
    }
    
    override def listLocks(request: uccp.coordination.coordination.ListLocksRequest): uccp.coordination.coordination.ListLocksResponse = {
      _root_.scalapb.grpc.ClientCalls.blockingUnaryCall(channel, METHOD_LIST_LOCKS, options, request)
    }
    
    override def build(channel: _root_.io.grpc.Channel, options: _root_.io.grpc.CallOptions): LockServiceBlockingStub = new LockServiceBlockingStub(channel, options)
  }
  
  class LockServiceStub(channel: _root_.io.grpc.Channel, options: _root_.io.grpc.CallOptions = _root_.io.grpc.CallOptions.DEFAULT) extends _root_.io.grpc.stub.AbstractStub[LockServiceStub](channel, options) with LockService {
    override def acquireLock(request: uccp.coordination.coordination.AcquireLockRequest): scala.concurrent.Future[uccp.coordination.coordination.AcquireLockResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_ACQUIRE_LOCK, options, request)
    }
    
    override def releaseLock(request: uccp.coordination.coordination.ReleaseLockRequest): scala.concurrent.Future[uccp.common.common.Response] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_RELEASE_LOCK, options, request)
    }
    
    override def renewLock(request: uccp.coordination.coordination.RenewLockRequest): scala.concurrent.Future[uccp.common.common.Response] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_RENEW_LOCK, options, request)
    }
    
    override def tryLock(request: uccp.coordination.coordination.TryLockRequest): scala.concurrent.Future[uccp.coordination.coordination.TryLockResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_TRY_LOCK, options, request)
    }
    
    override def acquireReadLock(request: uccp.coordination.coordination.AcquireReadLockRequest): scala.concurrent.Future[uccp.coordination.coordination.AcquireLockResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_ACQUIRE_READ_LOCK, options, request)
    }
    
    override def acquireSemaphore(request: uccp.coordination.coordination.AcquireSemaphoreRequest): scala.concurrent.Future[uccp.coordination.coordination.AcquireSemaphoreResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_ACQUIRE_SEMAPHORE, options, request)
    }
    
    override def releaseSemaphore(request: uccp.coordination.coordination.ReleaseSemaphoreRequest): scala.concurrent.Future[uccp.common.common.Response] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_RELEASE_SEMAPHORE, options, request)
    }
    
    override def waitBarrier(request: uccp.coordination.coordination.WaitBarrierRequest): scala.concurrent.Future[uccp.coordination.coordination.WaitBarrierResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_WAIT_BARRIER, options, request)
    }
    
    override def listLocks(request: uccp.coordination.coordination.ListLocksRequest): scala.concurrent.Future[uccp.coordination.coordination.ListLocksResponse] = {
      _root_.scalapb.grpc.ClientCalls.asyncUnaryCall(channel, METHOD_LIST_LOCKS, options, request)
    }
    
    override def build(channel: _root_.io.grpc.Channel, options: _root_.io.grpc.CallOptions): LockServiceStub = new LockServiceStub(channel, options)
  }
  
  object LockServiceStub extends _root_.io.grpc.stub.AbstractStub.StubFactory[LockServiceStub] {
    override def newStub(channel: _root_.io.grpc.Channel, options: _root_.io.grpc.CallOptions): LockServiceStub = new LockServiceStub(channel, options)
    
    implicit val stubFactory: _root_.io.grpc.stub.AbstractStub.StubFactory[LockServiceStub] = this
  }
  
  def bindService(serviceImpl: LockService, executionContext: scala.concurrent.ExecutionContext): _root_.io.grpc.ServerServiceDefinition = LockService.bindService(serviceImpl, executionContext)
  
  def blockingStub(channel: _root_.io.grpc.Channel): LockServiceBlockingStub = new LockServiceBlockingStub(channel)
  
  def stub(channel: _root_.io.grpc.Channel): LockServiceStub = new LockServiceStub(channel)
  
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.ServiceDescriptor = uccp.coordination.coordination.CoordinationProto.javaDescriptor.getServices().get(1)
  
}